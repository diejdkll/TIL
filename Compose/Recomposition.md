# **Recomposition**
> - Recomposition은 Jetpack Compose에서 중요한 개념 중 하나로, Composable 함수 내부에서 UI를 다시 그리고 업데이트하는 프로세스를 가리킨다.
> - 성능 향상을 위해 최적화되어 있으며, 변화가 있는 부분만 업데이트되므로 효율적으로 동작한다.

<br>

## **Recomposition 특징**
### 선언적 UI(Declarative UI)
- Recomposition은 선언적 UI 프로그래밍의 핵심이다. 
- UI를 설명하고 업데이트하는 대신 원하는 상태와 구조를 선언한다.
- 상태가 변경되면 Compose가 자동으로 UI를 다시 그려서 변경 사항을 반영한다.

### 상태 관리
- Recomposition은 상태를 효율적으로 관리한다.
- 상태가 변경될 때마다 필요한 부분만 다시 그려서 변경사항을 반영한다.

### 정적 타입 검사
- Kotlin 언어의 강력한 정적 타입 검사를 그대로 활용한다.
- 이로 인해 런타임 오류를 사전에 방지하고 안전한 코드를 작성할 수 있다.

### 부모-자식 관계 
- 부모 Composable이 변경되면 하위 자식 Composable도 다시 그려지므로 상태를 공유하고 업데이트 할 수 있다.

### 캐시 및 메모이제이션
- Compose는 변경되지 않은 Composable을 캐시하고 재사용하여 성능을 향상시킨다.

<br>

## **Recomposition 장점**
### 가독성과 유지 관리 용이성
- Recomposition을 통해 코드는 더 읽기 쉽고 유지 관리하기 쉬워진다.
- UI의 상태와 논리를 분리하고 변경 사항을 명확하게 정의할 수 있다.

### 높은 생산성
- 선언적 UI 프로그래밍 모델을 사용하는 UI를 더 쉽게 작성하고 업데이트 할 수 있으므로 개발자 생산성을 향상시킨다.

### UI 테스팅 및 디버깅 편의성
- Recomposition은 UI 테스팅 및 디버깅을 용이하게 만든다.
- UI 상태를 정확하게 예측할 수 있으므로 버그를 신속하게 해결할 수 있다.

### 코드 재사용
- Composable 함수를 작성하고 재사용할 수 있으므로 코드의 중복을 줄이고 모듈화된 UI 요소를 쉽게 구축할 수 있다.

### 동적 UI 작성
- Recomposition은 동적 UI를 쉽게 작성할 수 있도록 도와준다.
- 상태를 기반으로 UI를 동적으로 생성하고 업데이트할 수 있다. 

<br>

## **Recomposition 동작 원리와 구조**
### 1. Composable 함수 호출
- Recomposition은 Composable 함수 내부에서 시작된다.
- Composable 함수는 UI의 현재 상태를 정의하고 반환한다.
- Composable 함수는 선언적으로 UI를 설명하며 상태의 변경에 따라 호출된다.

### 2. 상태 변경 감지
- Recomposition은 Composable 함수의 상태 변경을 감지한다.
- 상태 변경은 주로 `remember` 나 `mutableStateOf` 와 같은 상태 관리 함수를 통해 발생하며, UI를 업데이트해야 할 필요가 있는 시점을 결정한다.

### 3. 변경된 부분 업데이트
- Recomposition은 변경된 부분을 효율적으로 업데이트한다. 
- 변경된 Composable 함수만을 다시 호출하고, 그 하위에 있는 Composable 함수들만을 업데이트한다. 
- 이는 전체 UI를 다시 그리지 않고도 변경 사항을 반영하는 데 도움이 된다.

### 4. 메모이제이션과 캐싱
- Recomposition은 이전에 그려진 Composable 함수들을 캐시하고 재사용한다. 
- 그리고 이전 호출과 현재 호출 사이에서 변경된 부분만 다시 그리고 업데이트한다. 이를 통해 성능이 향상된다.

### 5. 정적 타입 검사
- Kotlin의 정적 타입 검사를 활용하여 코드 안전성을 보장한다.
- Recomposition은 컴파일 시간에 오류를 감지하여 런타임 오류를 방지한다.

***